<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªØ³Øª PCM Ø¯Ø± Ù…Ø±ÙˆØ±Ú¯Ø±</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fafafa;
        }
        .test-section h3 {
            margin-top: 0;
            color: #555;
        }
        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover {
            background: #005a87;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .log {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ ØªØ³Øª PCM Audio Converter</h1>
        
        <div class="test-section">
            <h3>1. ØªØ³Øª Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Web Audio API</h3>
            <button onclick="testWebAudioSupport()">Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ</button>
            <div id="webAudioStatus"></div>
        </div>

        <div class="test-section">
            <h3>2. ØªØ³Øª ØªÙˆÙ„ÛŒØ¯ ÙØ§ÛŒÙ„ PCM</h3>
            <button onclick="testPCMGeneration()">ØªÙˆÙ„ÛŒØ¯ ÙØ§ÛŒÙ„ ØªØ³Øª PCM</button>
            <div id="pcmGenerationStatus"></div>
        </div>

        <div class="test-section">
            <h3>3. ØªØ³Øª Ø¶Ø¨Ø· ØµÙˆØª Ùˆ ØªØ¨Ø¯ÛŒÙ„ PCM</h3>
            <button id="recordBtn" onclick="startRecording()">Ø´Ø±ÙˆØ¹ Ø¶Ø¨Ø·</button>
            <button id="stopBtn" onclick="stopRecording()" disabled>ØªÙˆÙ‚Ù Ø¶Ø¨Ø·</button>
            <div id="recordingStatus"></div>
        </div>

        <div class="test-section">
            <h3>4. ØªØ³Øª API</h3>
            <button onclick="testAPI()">ØªØ³Øª API Ø¨Ø§ Ø¯Ø§Ø¯Ù‡ Ù†Ù…ÙˆÙ†Ù‡</button>
            <div id="apiStatus"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ“‹ Ù„Ø§Ú¯</h3>
            <button onclick="clearLog()">Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù„Ø§Ú¯</button>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script>
        let mediaRecorder = null;
        let audioChunks = [];
        let stream = null;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString('fa-IR');
            const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
            logDiv.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`${prefix} ${message}`);
        }

        function setStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function clearLog() {
            document.getElementById('log').textContent = '';
        }

        // ØªØ³Øª 1: Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Web Audio API
        function testWebAudioSupport() {
            log('Ø´Ø±ÙˆØ¹ ØªØ³Øª Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Web Audio API...');
            
            const hasAudioContext = !!(window.AudioContext || window.webkitAudioContext);
            const hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            const hasMediaRecorder = !!window.MediaRecorder;
            const isSecureContext = window.isSecureContext;

            if (hasAudioContext && hasMediaDevices && hasMediaRecorder && isSecureContext) {
                setStatus('webAudioStatus', 'âœ… ØªÙ…Ø§Ù… Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯', 'success');
                log('ØªÙ…Ø§Ù… Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ù…ÙˆØ¬ÙˆØ¯ Ø§Ø³Øª', 'success');
            } else {
                let issues = [];
                if (!hasAudioContext) issues.push('AudioContext');
                if (!hasMediaDevices) issues.push('MediaDevices');
                if (!hasMediaRecorder) issues.push('MediaRecorder');
                if (!isSecureContext) issues.push('Secure Context (HTTPS)');
                
                setStatus('webAudioStatus', `âŒ Ù…Ø´Ú©Ù„ Ø¯Ø±: ${issues.join(', ')}`, 'error');
                log(`Ù…Ø´Ú©Ù„ Ø¯Ø±: ${issues.join(', ')}`, 'error');
            }

            log(`AudioContext: ${hasAudioContext ? 'Ù…ÙˆØ¬ÙˆØ¯' : 'Ù…ÙÙ‚ÙˆØ¯'}`);
            log(`MediaDevices: ${hasMediaDevices ? 'Ù…ÙˆØ¬ÙˆØ¯' : 'Ù…ÙÙ‚ÙˆØ¯'}`);
            log(`MediaRecorder: ${hasMediaRecorder ? 'Ù…ÙˆØ¬ÙˆØ¯' : 'Ù…ÙÙ‚ÙˆØ¯'}`);
            log(`Secure Context: ${isSecureContext ? 'Ø¨Ù„Ù‡' : 'Ø®ÛŒØ±'}`);
        }

        // ØªØ³Øª 2: ØªÙˆÙ„ÛŒØ¯ ÙØ§ÛŒÙ„ PCM
        async function testPCMGeneration() {
            log('Ø´Ø±ÙˆØ¹ ØªØ³Øª ØªÙˆÙ„ÛŒØ¯ PCM...');
            
            try {
                // ØªÙˆÙ„ÛŒØ¯ ÛŒÚ© sine wave Ú©ÙˆØªØ§Ù‡
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const sampleRate = 16000;
                const duration = 0.5;
                const samples = sampleRate * duration;
                
                const audioBuffer = audioContext.createBuffer(1, samples, sampleRate);
                const channelData = audioBuffer.getChannelData(0);
                
                // ØªÙˆÙ„ÛŒØ¯ 440Hz sine wave
                for (let i = 0; i < samples; i++) {
                    channelData[i] = Math.sin(2 * Math.PI * 440 * i / sampleRate) * 0.1;
                }
                
                log(`AudioBuffer ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯: ${samples} samples, ${sampleRate}Hz`);
                
                // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ PCM 16-bit
                const pcm16 = new ArrayBuffer(samples * 2);
                const view = new DataView(pcm16);
                
                for (let i = 0; i < samples; i++) {
                    const sample = Math.max(-1, Math.min(1, channelData[i]));
                    const pcmSample = Math.round(sample * 32767);
                    view.setInt16(i * 2, pcmSample, true);
                }
                
                // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ base64
                const bytes = new Uint8Array(pcm16);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                const base64 = btoa(binary);
                
                log(`PCM ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯: ${pcm16.byteLength} bytes, base64 length: ${base64.length}`);
                setStatus('pcmGenerationStatus', `âœ… PCM ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯: ${pcm16.byteLength} bytes`, 'success');
                
                await audioContext.close();
                
            } catch (error) {
                log(`Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ PCM: ${error.message}`, 'error');
                setStatus('pcmGenerationStatus', `âŒ Ø®Ø·Ø§: ${error.message}`, 'error');
            }
        }

        // ØªØ³Øª 3: Ø¶Ø¨Ø· ØµÙˆØª
        async function startRecording() {
            log('Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ†...');
            
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });
                
                log('Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ† Ù…ÙˆÙÙ‚');
                
                audioChunks = [];
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                        log(`Ø¯Ø§Ø¯Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯: ${event.data.size} bytes`);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    log('Ø¶Ø¨Ø· Ù…ØªÙˆÙ‚Ù Ø´Ø¯ØŒ Ø´Ø±ÙˆØ¹ Ù¾Ø±Ø¯Ø§Ø²Ø´...');
                    await processRecording();
                };
                
                mediaRecorder.start(1000);
                
                document.getElementById('recordBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                setStatus('recordingStatus', 'ğŸ¤ Ø¯Ø± Ø­Ø§Ù„ Ø¶Ø¨Ø·... (Ø­Ø¯Ø§Ú©Ø«Ø± 10 Ø«Ø§Ù†ÛŒÙ‡)', 'info');
                log('Ø¶Ø¨Ø· Ø´Ø±ÙˆØ¹ Ø´Ø¯');
                
                // ØªÙˆÙ‚Ù Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ø¹Ø¯ Ø§Ø² 10 Ø«Ø§Ù†ÛŒÙ‡
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        stopRecording();
                    }
                }, 10000);
                
            } catch (error) {
                log(`Ø®Ø·Ø§ Ø¯Ø± Ø´Ø±ÙˆØ¹ Ø¶Ø¨Ø·: ${error.message}`, 'error');
                setStatus('recordingStatus', `âŒ Ø®Ø·Ø§: ${error.message}`, 'error');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                log('Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªÙˆÙ‚Ù Ø¶Ø¨Ø· Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯');
            }
            
            document.getElementById('recordBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        async function processRecording() {
            try {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                log(`ÙØ§ÛŒÙ„ ØµÙˆØªÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯: ${audioBlob.size} bytes`);
                
                // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ PCM
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                log(`ØµÙˆØª decode Ø´Ø¯: ${audioBuffer.length} samples, ${audioBuffer.sampleRate}Hz, ${audioBuffer.numberOfChannels} channels`);
                
                // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ mono
                const monoData = audioBuffer.numberOfChannels === 1 
                    ? audioBuffer.getChannelData(0)
                    : convertToMono(audioBuffer);
                
                // resample Ø¨Ù‡ 16kHz Ø§Ú¯Ø± Ù†ÛŒØ§Ø² Ø¨Ø§Ø´Ø¯
                const resampledData = audioBuffer.sampleRate === 16000 
                    ? monoData 
                    : await resampleTo16kHz(monoData, audioBuffer.sampleRate);
                
                // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ PCM 16-bit
                const pcm16 = convertToPCM16(resampledData);
                const base64 = arrayBufferToBase64(pcm16);
                
                log(`PCM Ù†Ù‡Ø§ÛŒÛŒ: ${pcm16.byteLength} bytes, base64: ${base64.length} chars`);
                setStatus('recordingStatus', `âœ… Ø¶Ø¨Ø· Ùˆ ØªØ¨Ø¯ÛŒÙ„ Ù…ÙˆÙÙ‚: ${pcm16.byteLength} bytes PCM`, 'success');
                
                // ØªØ³Øª API Ø¨Ø§ Ø¯Ø§Ø¯Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ
                await testAPIWithData(base64);
                
                await audioContext.close();
                
            } catch (error) {
                log(`Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¶Ø¨Ø·: ${error.message}`, 'error');
                setStatus('recordingStatus', `âŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´: ${error.message}`, 'error');
            } finally {
                // Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
            }
        }

        function convertToMono(audioBuffer) {
            if (audioBuffer.numberOfChannels === 1) {
                return audioBuffer.getChannelData(0);
            }
            
            const leftChannel = audioBuffer.getChannelData(0);
            const rightChannel = audioBuffer.getChannelData(1);
            const monoData = new Float32Array(leftChannel.length);
            
            for (let i = 0; i < leftChannel.length; i++) {
                monoData[i] = (leftChannel[i] + rightChannel[i]) / 2;
            }
            
            return monoData;
        }

        function resampleTo16kHz(inputData, inputSampleRate) {
            if (inputSampleRate === 16000) {
                return inputData;
            }
            
            const ratio = inputSampleRate / 16000;
            const outputLength = Math.floor(inputData.length / ratio);
            const outputData = new Float32Array(outputLength);
            
            for (let i = 0; i < outputLength; i++) {
                const sourceIndex = i * ratio;
                const index = Math.floor(sourceIndex);
                const fraction = sourceIndex - index;
                
                if (index + 1 < inputData.length) {
                    outputData[i] = inputData[index] * (1 - fraction) + inputData[index + 1] * fraction;
                } else {
                    outputData[i] = inputData[index];
                }
            }
            
            return outputData;
        }

        function convertToPCM16(floatData) {
            const pcm16 = new ArrayBuffer(floatData.length * 2);
            const view = new DataView(pcm16);
            
            for (let i = 0; i < floatData.length; i++) {
                const sample = Math.max(-1, Math.min(1, floatData[i]));
                const pcmSample = Math.round(sample * 32767);
                view.setInt16(i * 2, pcmSample, true);
            }
            
            return pcm16;
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        // ØªØ³Øª 4: API
        async function testAPI() {
            // ØªÙˆÙ„ÛŒØ¯ Ø¯Ø§Ø¯Ù‡ ØªØ³Øª
            const testData = btoa('test audio data');
            await testAPIWithData(testData);
        }

        async function testAPIWithData(base64Data) {
            log('Ø´Ø±ÙˆØ¹ ØªØ³Øª API...');
            setStatus('apiStatus', 'ğŸ”„ Ø¯Ø± Ø­Ø§Ù„ ØªØ³Øª API...', 'info');
            
            try {
                const response = await fetch('/api/voice-analysis/sahab-speech-recognition', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        data: base64Data,
                        language: 'fa',
                        format: 'pcm',
                        sampleRate: 16000,
                        channels: 1,
                        bitDepth: 16
                    })
                });
                
                log(`Ù¾Ø§Ø³Ø® API: HTTP ${response.status}`);
                
                const result = await response.json();
                log(`Ù¾Ø§Ø³Ø® JSON: ${JSON.stringify(result, null, 2)}`);
                
                if (response.ok && result.success) {
                    setStatus('apiStatus', `âœ… API Ù…ÙˆÙÙ‚: ${result.data?.text || 'Ø¨Ø¯ÙˆÙ† Ù…ØªÙ†'}`, 'success');
                    log('API Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯', 'success');
                } else {
                    setStatus('apiStatus', `âš ï¸ API Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯ Ø§Ù…Ø§ Ù†ØªÛŒØ¬Ù‡ Ù…Ø·Ù„ÙˆØ¨ Ù†Ø¨ÙˆØ¯: ${result.message}`, 'warning');
                    log(`API Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯ Ø§Ù…Ø§ Ù…Ø´Ú©Ù„ Ø¯Ø§Ø±Ø¯: ${result.message}`, 'warning');
                }
                
            } catch (error) {
                log(`Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª API: ${error.message}`, 'error');
                setStatus('apiStatus', `âŒ Ø®Ø·Ø§ Ø¯Ø± API: ${error.message}`, 'error');
            }
        }

        // Ø´Ø±ÙˆØ¹ Ø®ÙˆØ¯Ú©Ø§Ø± ØªØ³Øª Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ
        window.onload = function() {
            log('ØµÙØ­Ù‡ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯ØŒ Ø´Ø±ÙˆØ¹ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ‡...');
            testWebAudioSupport();
        };
    </script>
</body>
</html>